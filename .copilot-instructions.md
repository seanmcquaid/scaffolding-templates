# Scaffolding Templates - CoPilot Instructions

## Purpose
This repository contains a collection of opinionated scaffolding templates for modern web development projects. Each template is designed to provide a solid starting point with best practices, modern tooling, and consistent patterns across different frameworks and use cases.

## Repository Structure
- **Root Level**: Repository management with pnpm workspace configuration
- **templates/**: Contains individual template directories, each representing a complete project scaffold

## Available Templates
1. **typescript-library**: Library template with TypeScript, build tools, testing, and publishing setup
2. **next-ssr**: Next.js server-side rendered application with modern React patterns
3. **react-router-v7-spa**: Single-page application using React Router v7
4. **react-router-v7-ssr**: Server-side rendered application using React Router v7
5. **tanstack-router-spa**: Single-page application using TanStack Router
6. **tanstack-start-ssr**: Server-side rendered application using TanStack Start

## Coding Standards & Patterns

### Package Management
- Use **pnpm** as the package manager throughout all templates
- Maintain consistent Node.js version (>=22.12.0) across templates
- Use workspace configuration for managing multiple templates

### Code Quality Tools
- **Biome**: Used for linting and formatting (replacing ESLint/Prettier)
- **TypeScript**: All templates use TypeScript with strict configuration
- **Husky**: Git hooks for pre-commit validation
- **lint-staged**: Run linters on staged files only

### Testing Strategy
- **Vitest**: Primary testing framework for unit/integration tests
- **Playwright**: End-to-end testing for frontend applications
- **@testing-library/react**: Component testing utilities
- **MSW (Mock Service Worker)**: API mocking for testing

### Build & Development
- **Vite**: Primary build tool for most templates
- **tsup**: Build tool for TypeScript libraries
- **Turbopack**: Used with Next.js for fast development

### Common Architectural Patterns

#### File Organization
Follow consistent directory structure across templates:
- `/src` or `/app`: Main application source code
- `/components`: Reusable UI components (ui/ and app/ subdirectories)
- `/hooks`: Custom React hooks
- `/services`: API client and data fetching logic
- `/types`: TypeScript type definitions
- `/utils`: Utility functions
- `/constants`: Application constants and enums
- `/docs`: Template-specific documentation

#### Component Patterns
- Separate UI components (presentational) from app components (feature-specific)
- Use TypeScript interfaces for component props
- Implement proper error boundaries and loading states

#### State Management
- **TanStack Query**: For server state management
- **React Hook Form**: For form state management
- Local component state with useState/useReducer for UI state

#### Styling
- **Tailwind CSS**: Utility-first CSS framework
- **shadcn/ui**: Component library built on Radix UI
- **CSS Modules**: When component-scoped styles are needed

#### Internationalization (i18n)
- **i18next**: Primary i18n solution
- **react-i18next**: React bindings for i18next
- Type-safe translation keys

## Development Guidelines

### When Adding New Templates
1. Follow the established directory structure
2. Include comprehensive documentation in `/docs` folder
3. Set up consistent tooling (Biome, Husky, testing, etc.)
4. Create appropriate package.json scripts
5. Include example environment files
6. Add bundlesize configuration for performance monitoring

### When Modifying Existing Templates
- Maintain backward compatibility when possible
- Update documentation to reflect changes
- Test across all supported Node.js versions
- Ensure all templates continue to follow the same patterns

### API Clients
- Use **ky** for HTTP requests with proper error handling
- Implement validation using **Zod** schemas
- Create typed API clients with automatic response validation
- Include retry logic and proper error boundaries

### Performance Considerations
- Monitor bundle sizes with bundlesize configuration
- Implement code splitting where appropriate
- Use lazy loading for routes and heavy components
- Include performance budgets in CI/CD

## Contributing Guidelines
- Each template should be self-contained and fully functional
- Include comprehensive README and documentation
- Follow the established coding patterns and tool choices
- Test templates thoroughly before submitting changes
- Maintain consistency across all templates while respecting framework-specific patterns