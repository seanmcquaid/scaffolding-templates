name: AI Test Coverage Analysis
on:
  schedule:
    # Run every Monday at 10:00 AM UTC
    - cron: '0 10 * * 1'
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: read
  issues: write

env:
  MIN_COVERAGE_THRESHOLD: 80

jobs:
  analyze-coverage:
    runs-on: ubuntu-latest
    name: Analyze Test Coverage Gaps
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup PNPM
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Run Coverage Analysis
        id: coverage
        continue-on-error: true
        run: |
          # Run coverage analysis script
          ./scripts/run-coverage-analysis.sh coverage-reports
          
          # Extract coverage summary
          COVERAGE_SUMMARY=""
          for TEMPLATE in typescript-library next-ssr react-router-v7-spa react-router-v7-ssr tanstack-router-spa expo-react-native; do
            if [ -f "templates/$TEMPLATE/coverage/coverage-summary.json" ]; then
              TOTAL=$(jq -r '.total' "templates/$TEMPLATE/coverage/coverage-summary.json" 2>/dev/null || echo "{}")
              COVERAGE_SUMMARY="$COVERAGE_SUMMARY\n$TEMPLATE: $TOTAL"
            fi
          done
          
          echo "coverage_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COVERAGE_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Identify Coverage Gaps
        id: gaps
        run: |
          # Run coverage gaps script with JSON output
          GAPS_JSON=$(./scripts/identify-coverage-gaps.sh ${{ env.MIN_COVERAGE_THRESHOLD }} --format json 2>/dev/null)
          
          # Also get text format for backwards compatibility
          GAPS_TEXT=$(./scripts/identify-coverage-gaps.sh ${{ env.MIN_COVERAGE_THRESHOLD }} | grep -E "^[a-z-]+: " || echo "")
          
          echo "gaps_json<<EOF" >> $GITHUB_OUTPUT
          echo "$GAPS_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "gaps<<EOF" >> $GITHUB_OUTPUT
          echo -e "$GAPS_TEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Identify Missing Test Types
        id: missing-tests
        run: |
          # Run missing tests script and capture output
          MISSING=$(./scripts/identify-missing-tests.sh | grep -E "^[a-z-]+: " || echo "")
          
          echo "missing<<EOF" >> $GITHUB_OUTPUT
          echo -e "$MISSING" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate Coverage Gap Issues
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const gapsJson = `${{ steps.gaps.outputs.gaps_json }}`;
            const missing = `${{ steps.missing-tests.outputs.missing }}`;
            
            let templatesData = [];
            try {
              templatesData = JSON.parse(gapsJson);
            } catch (e) {
              console.error('Failed to parse gaps JSON:', e);
              return;
            }
            
            // Parse missing tests data
            const missingTests = {};
            if (missing) {
              missing.split('\n').filter(line => line.trim() && line.includes(':')).forEach(line => {
                const [template, ...rest] = line.split(':');
                if (!missingTests[template]) {
                  missingTests[template] = [];
                }
                missingTests[template].push(rest.join(':').trim());
              });
            }
            
            for (const templateData of templatesData) {
              const template = templateData.template;
              
              // Skip if no gaps and no missing tests
              if (!templateData.has_gaps && (!missingTests[template] || missingTests[template].length === 0)) {
                continue;
              }
              
              // Skip if there's an error
              if (templateData.error) {
                console.log(\`âŠ˜ Skipping ${template}: ${templateData.error}\`);
                continue;
              }
              
              const title = \`[Test Coverage] Improve ${template} test coverage\`;
              
              // Build coverage metrics section
              let coverageMetrics = '| Metric | Current | Target | Gap |\n';
              coverageMetrics += '|--------|---------|--------|-----|\n';
              
              if (templateData.coverage) {
                const cov = templateData.coverage;
                if (cov.lines) {
                  const gap = cov.lines.total - cov.lines.covered;
                  coverageMetrics += \`| **Lines** | ${cov.lines.pct}% (${cov.lines.covered}/${cov.lines.total}) | ${{ env.MIN_COVERAGE_THRESHOLD }}% | ${gap} lines |\n\`;
                }
                if (cov.branches) {
                  const gap = cov.branches.total - cov.branches.covered;
                  coverageMetrics += \`| **Branches** | ${cov.branches.pct}% (${cov.branches.covered}/${cov.branches.total}) | ${{ env.MIN_COVERAGE_THRESHOLD }}% | ${gap} branches |\n\`;
                }
                if (cov.functions) {
                  const gap = cov.functions.total - cov.functions.covered;
                  coverageMetrics += \`| **Functions** | ${cov.functions.pct}% (${cov.functions.covered}/${cov.functions.total}) | ${{ env.MIN_COVERAGE_THRESHOLD }}% | ${gap} functions |\n\`;
                }
                if (cov.statements) {
                  coverageMetrics += \`| **Statements** | ${cov.statements.pct}% | ${{ env.MIN_COVERAGE_THRESHOLD }}% | - |\n\`;
                }
              }
              
              // Build specific gaps section
              let gapsSection = '';
              if (templateData.gaps && templateData.gaps.length > 0) {
                gapsSection = '### ðŸ“Š Coverage Gaps by Type\n\n';
                for (const gap of templateData.gaps) {
                  const emoji = gap.type === 'line' ? 'ðŸ“' : gap.type === 'branch' ? 'ðŸ”€' : 'âš¡';
                  gapsSection += \`${emoji} **${gap.type.charAt(0).toUpperCase() + gap.type.slice(1)} Coverage**\n\`;
                  gapsSection += \`- Current: ${gap.current}%\n\`;
                  gapsSection += \`- Target: ${gap.target}%\n\`;
                  gapsSection += \`- Missing: ${gap.missing} ${gap.type}s need coverage\n\n\`;
                }
              }
              
              // Build low coverage files section
              let lowCoverageSection = '';
              if (templateData.low_coverage_files && templateData.low_coverage_files.length > 0) {
                lowCoverageSection = '### ðŸŽ¯ Files Needing Attention\n\n';
                lowCoverageSection += 'These files have the lowest coverage and should be prioritized:\n\n';
                lowCoverageSection += '| File | Coverage | Uncovered Lines |\n';
                lowCoverageSection += '|------|----------|----------------|\n';
                for (const file of templateData.low_coverage_files) {
                  lowCoverageSection += \`| \\\`${file.file}\\\` | ${file.coverage}% | ${file.uncovered}/${file.total} |\n\`;
                }
                lowCoverageSection += '\n';
              }
              
              // Build missing tests section
              let missingTestsSection = '';
              if (missingTests[template] && missingTests[template].length > 0) {
                missingTestsSection = '### âš ï¸  Missing Test Types\n\n';
                missingTestsSection += missingTests[template].map(t => \`- ${t}\`).join('\n') + '\n\n';
              }
              
              // Get template specialist
              const specialistMap = {
                'typescript-library': 'typescript-library-specialist',
                'next-ssr': 'nextjs-ssr-specialist',
                'react-router-v7-spa': 'react-router-spa-specialist',
                'react-router-v7-ssr': 'react-router-ssr-specialist',
                'tanstack-router-spa': 'tanstack-router-spa-specialist',
                'expo-react-native': 'expo-react-native-specialist'
              };
              const specialist = specialistMap[template] || 'implementation-engineer';
              
              const body = \`## ðŸ§ª Test Coverage Gap Analysis

**Template**: \\\`${template}\\\`
**Analysis Date**: ${new Date().toISOString().split('T')[0]}
**Coverage Threshold**: ${{ env.MIN_COVERAGE_THRESHOLD }}%

### ðŸ“ˆ Coverage Metrics

${coverageMetrics}

${gapsSection}${lowCoverageSection}${missingTestsSection}

### ðŸ’¡ Recommended Actions

Based on the analysis, here are prioritized actions:

1. **High Priority** - Files with <50% coverage
   - Focus on critical paths and error handling
   - Add unit tests for core functionality
   
2. **Medium Priority** - Files with 50-${${{ env.MIN_COVERAGE_THRESHOLD }}}% coverage
   - Add tests for edge cases
   - Improve branch coverage
   
3. **Low Priority** - Files near threshold
   - Add tests for remaining branches
   - Test error conditions

### ðŸ§ª Testing Strategy

#### Unit Tests
- âœ… Test individual components in isolation
- âœ… Test custom hooks independently with \`@testing-library/react-hooks\`
- âœ… Test utility functions thoroughly with edge cases
- âœ… Mock external dependencies properly

#### Integration Tests  
- âœ… Test component interactions and data flow
- âœ… Test API integration with MSW (Mock Service Worker)
- âœ… Test routing and navigation flows
- âœ… Test form submissions and validations

#### E2E Tests (Optional, run separately)
- âœ… Test critical user journeys end-to-end
- âœ… Test with real APIs in staging environment
- âœ… Focus on high-value, business-critical flows
- âœ… Keep E2E tests minimal and maintainable

### ðŸ“‹ Testing Best Practices

**From Repository Documentation:**

1. **Unit Tests**: Components, hooks, utils, pages
   - Fast and isolated
   - Run on every commit
   - Mock external dependencies

2. **Integration Tests**: Happy path flows with mocked APIs
   - Use MSW for API mocking
   - Test feature workflows
   - Cover user interactions

3. **E2E Tests**: High-level user flows with real APIs
   - Use Playwright
   - Run in CI/CD after deployment
   - Keep slow tests out of PR checks

### ðŸŽ¯ Implementation Plan

- [ ] **Phase 1: Analysis** (Use @quality-analyst agent)
  - Review existing test files and patterns
  - Identify untested code paths from coverage report
  - Plan specific test cases for missing coverage
  - Estimate effort and prioritize work

- [ ] **Phase 2: Implementation** (Use @${specialist} agent)
  - Write tests following template patterns
  - Use appropriate testing utilities (@testing-library/react, etc.)
  - Ensure tests are maintainable and well-documented
  - Follow AAA pattern (Arrange, Act, Assert)

- [ ] **Phase 3: Validation**
  - Run \\\`pnpm test:coverage\\\` locally
  - Verify coverage meets or exceeds ${${{ env.MIN_COVERAGE_THRESHOLD }}}% threshold
  - Ensure all tests pass consistently
  - Review test quality and maintainability

- [ ] **Phase 4: Documentation**
  - Document any new testing patterns
  - Update test documentation if needed
  - Add inline comments for complex test scenarios

### ðŸ‘¥ Relevant Agents

- **@quality-analyst** - Test strategy, implementation, and coverage analysis
- **@${specialist}** - Framework-specific test patterns and best practices
- **@implementation-engineer** - Code implementation support

### ðŸ“š Resources

- [Testing Library Documentation](https://testing-library.com/docs/react-testing-library/intro/)
- [Vitest Documentation](https://vitest.dev/)
- [MSW Documentation](https://mswjs.io/)
- [Repository Testing Guide](/docs/testing-strategy.md)

---
*This issue was automatically generated by AI test coverage analysis workflow.*
*Run \\\`./scripts/identify-coverage-gaps.sh ${${{ env.MIN_COVERAGE_THRESHOLD }}}\\\` locally to see current gaps.*
*See [\\\`/docs/ai-workflows.md\\\`](/docs/ai-workflows.md) for workflow details.*
\`;
              
              // Check if similar issue already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'ai-generated,coverage-gap',
                state: 'open'
              });
              
              const isDuplicate = existingIssues.data.some(issue => 
                issue.title.toLowerCase().includes(template.toLowerCase())
              );
              
              if (!isDuplicate) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: ['ai-generated', 'coverage-gap', 'testing', \`template:${template}\`]
                });
                
                console.log(\`âœ“ Created issue: ${title}\`);
              } else {
                console.log(\`âŠ˜ Skipping duplicate issue: ${title}\`);
              }
            }
                
                console.log(`Created issue: ${title}`);
              } else {
                console.log(`Skipping duplicate issue: ${title}`);
              }
            }

      - name: Create Coverage Report Summary
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const coverageSummary = `${{ steps.coverage.outputs.coverage_summary }}`;
            const gaps = `${{ steps.gaps.outputs.gaps }}`;
            const missing = `${{ steps.missing-tests.outputs.missing }}`;
            
            const gapLines = gaps.split('\n').filter(l => l.trim());
            const missingLines = missing.split('\n').filter(l => l.trim());
            
            core.summary
              .addHeading('ðŸ§ª Test Coverage Analysis Report')
              .addHeading(`Date: ${new Date().toISOString().split('T')[0]}`, 3)
              .addHeading(`Coverage Threshold: ${{ env.MIN_COVERAGE_THRESHOLD }}%`, 3)
              .addHeading('Coverage Gaps', 3)
              .addList(gapLines.length > 0 ? gapLines : ['âœ“ All templates meet coverage threshold'])
              .addHeading('Missing Test Types', 3)
              .addList(missingLines.length > 0 ? missingLines : ['âœ“ All test types present'])
              .addHeading('Next Steps', 3)
              .addRaw(`
              1. Review generated issues with \`ai-generated\` and \`coverage-gap\` labels
              2. Use @quality-analyst agent to plan test improvements
              3. Use template specialist agents for framework-specific patterns
              4. Validate coverage improvements with \`pnpm test:coverage\`
              `)
              .addLink('View AI Workflows Documentation', '/docs/ai-workflows.md')
              .write();
