# React Router V7 SPA Template - CoPilot Instructions

## Purpose
This template provides a modern single-page application built with React Router V7, featuring client-side routing, modern React patterns, and comprehensive development tooling. It's designed for applications that prioritize client-side interactions and don't require server-side rendering.

## Technology Stack
- **React Router V7**: Modern client-side routing with file-based routing
- **React 19**: Latest React with concurrent features
- **TypeScript**: Full type safety with strict configuration
- **Vite**: Fast development server and build tool
- **TanStack Query**: Server state management and caching
- **React Hook Form + Zod**: Type-safe form handling with validation
- **Tailwind CSS**: Utility-first styling framework
- **shadcn/ui**: Component library built on Radix UI
- **i18next**: Internationalization with type safety
- **Vitest + Playwright**: Unit and end-to-end testing

## Project Architecture

### File Structure
```
app/
├── entry.client.tsx       # Client-side application entry point
├── root.tsx              # Root component with providers and layout
├── routes.ts             # Route configuration
├── routes/               # Route components and pages
│   ├── _index.tsx       # Home page route
│   └── [feature]/       # Feature-based route organization
├── components/           # Reusable components
│   ├── ui/              # Base UI components (shadcn/ui)
│   └── app/             # Application-specific components
├── services/            # API clients and data fetching
├── hooks/               # Custom React hooks
├── utils/               # Utility functions
├── types/               # TypeScript definitions
├── constants/           # Application constants
├── i18n/               # Internationalization
└── styles/             # Global styles and CSS
```

## React Router V7 Patterns

### Route Configuration
```typescript
// routes.ts
import { index, route, type RouteConfig } from "@react-router/dev/routes";

export default [
  index("routes/_index.tsx"),
  route("about", "routes/about.tsx"),
  route("dashboard", "routes/dashboard.tsx", [
    route("analytics", "routes/dashboard.analytics.tsx"),
    route("settings", "routes/dashboard.settings.tsx"),
  ]),
] satisfies RouteConfig;
```

### Route Components
```typescript
// routes/_index.tsx
import type { Route } from "./+types/_index";
import { WelcomeSection } from "~/components/app/WelcomeSection";

export function meta({}: Route.MetaArgs) {
  return [
    { title: "Home - My App" },
    { name: "description", content: "Welcome to my application" },
  ];
}

export default function HomePage({}: Route.ComponentProps) {
  return (
    <div className="container mx-auto px-4 py-8">
      <WelcomeSection />
    </div>
  );
}
```

### Data Loading
```typescript
// routes/dashboard.tsx
import type { Route } from "./+types/dashboard";
import { dashboardService } from "~/services/dashboardService";

export async function clientLoader({}: Route.ClientLoaderArgs) {
  const data = await dashboardService.getData();
  return { data };
}

export default function Dashboard({ loaderData }: Route.ComponentProps) {
  const { data } = loaderData;
  
  return (
    <div>
      <h1>Dashboard</h1>
      <DashboardContent data={data} />
    </div>
  );
}
```

## Development Patterns

### Client-Side Navigation
```typescript
import { Link, useNavigate } from "react-router";

export function Navigation() {
  const navigate = useNavigate();
  
  return (
    <nav>
      <Link to="/" className="nav-link">Home</Link>
      <Link to="/about" className="nav-link">About</Link>
      <button onClick={() => navigate("/dashboard")}>
        Go to Dashboard
      </button>
    </nav>
  );
}
```

### Form Handling with Navigation
```typescript
import { Form, useActionData, useNavigation } from "react-router";
import type { Route } from "./+types/contact";

export async function clientAction({ request }: Route.ClientActionArgs) {
  const formData = await request.formData();
  const result = await submitContact(formData);
  
  if (result.success) {
    return redirect("/thank-you");
  }
  
  return { errors: result.errors };
}

export default function ContactPage({}: Route.ComponentProps) {
  const actionData = useActionData<typeof clientAction>();
  const navigation = useNavigation();
  const isSubmitting = navigation.state === "submitting";
  
  return (
    <Form method="post">
      <input name="email" type="email" required />
      {actionData?.errors?.email && (
        <p className="error">{actionData.errors.email}</p>
      )}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </Form>
  );
}
```

## State Management Strategy

### Server State (TanStack Query)
```typescript
// hooks/services/useUserProfile.ts
import { useQuery } from '@tanstack/react-query';
import { userService } from '~/services/userService';

export function useUserProfile(userId: string) {
  return useQuery({
    queryKey: ['user', 'profile', userId],
    queryFn: () => userService.getProfile(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 2,
  });
}
```

### Client State Management
```typescript
// For simple component state
const [isOpen, setIsOpen] = useState(false);

// For complex state with useReducer
type State = {
  status: 'idle' | 'loading' | 'success' | 'error';
  data: any;
  error: string | null;
};

type Action = 
  | { type: 'LOADING' }
  | { type: 'SUCCESS'; payload: any }
  | { type: 'ERROR'; payload: string };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'LOADING':
      return { ...state, status: 'loading', error: null };
    case 'SUCCESS':
      return { ...state, status: 'success', data: action.payload };
    case 'ERROR':
      return { ...state, status: 'error', error: action.payload };
    default:
      return state;
  }
}
```

## Component Architecture

### Root Component Setup
```typescript
// root.tsx
import { Links, Meta, Outlet, Scripts, ScrollRestoration } from "react-router";
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from '~/components/ui/toaster';

const queryClient = new QueryClient();

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <QueryClientProvider client={queryClient}>
          <div className="min-h-screen bg-background">
            <Outlet />
            <Toaster />
          </div>
        </QueryClientProvider>
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

### Reusable Components
```typescript
// components/app/DataTable.tsx
interface DataTableProps<T> {
  data: T[];
  columns: ColumnDef<T>[];
  onRowClick?: (row: T) => void;
}

export function DataTable<T>({ 
  data, 
  columns, 
  onRowClick 
}: DataTableProps<T>) {
  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {/* Table header implementation */}
        </TableHeader>
        <TableBody>
          {data.map((row, index) => (
            <TableRow 
              key={index}
              onClick={() => onRowClick?.(row)}
              className="cursor-pointer hover:bg-muted/50"
            >
              {/* Table row implementation */}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

## API Integration

### Service Layer Pattern
```typescript
// services/apiClient.ts
import ky from 'ky';
import { clientEnv } from '~/env.client';

export const apiClient = ky.create({
  prefixUrl: clientEnv.VITE_API_URL,
  hooks: {
    beforeRequest: [
      (request) => {
        const token = localStorage.getItem('auth-token');
        if (token) {
          request.headers.set('Authorization', `Bearer ${token}`);
        }
      },
    ],
    afterResponse: [
      async (_, __, response) => {
        if (response.status === 401) {
          // Handle auth errors
          localStorage.removeItem('auth-token');
          window.location.href = '/login';
        }
        return response;
      },
    ],
  },
});
```

### Type-Safe API Calls
```typescript
// services/postsService.ts
import { z } from 'zod';
import { apiClient } from './apiClient';

const PostSchema = z.object({
  id: z.string(),
  title: z.string(),
  content: z.string(),
  publishedAt: z.string().transform(val => new Date(val)),
});

export type Post = z.infer<typeof PostSchema>;

export const postsService = {
  async getAll(): Promise<Post[]> {
    const response = await apiClient.get('posts').json();
    return z.array(PostSchema).parse(response);
  },
  
  async getById(id: string): Promise<Post> {
    const response = await apiClient.get(`posts/${id}`).json();
    return PostSchema.parse(response);
  },
};
```

## Testing Patterns

### Component Testing
```typescript
// components/__tests__/Navigation.test.tsx
import { render, screen } from '@testing-library/react';
import { createMemoryRouter, RouterProvider } from 'react-router';
import { Navigation } from '../Navigation';

function renderWithRouter(initialEntries = ['/']) {
  const router = createMemoryRouter([
    { path: '*', element: <Navigation /> },
  ], { initialEntries });
  
  return render(<RouterProvider router={router} />);
}

describe('Navigation', () => {
  it('renders navigation links', () => {
    renderWithRouter();
    
    expect(screen.getByRole('link', { name: 'Home' })).toBeInTheDocument();
    expect(screen.getByRole('link', { name: 'About' })).toBeInTheDocument();
  });
});
```

### Route Testing
```typescript
// routes/__tests__/_index.test.tsx
import { render, screen } from '@testing-library/react';
import { createMemoryRouter, RouterProvider } from 'react-router';
import HomePage from '../_index';

describe('HomePage', () => {
  it('renders welcome section', () => {
    const router = createMemoryRouter([
      { path: '/', element: <HomePage /> },
    ], { initialEntries: ['/'] });
    
    render(<RouterProvider router={router} />);
    
    expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();
  });
});
```

## Performance Optimization

### Code Splitting
```typescript
// Lazy load route components
import { lazy } from 'react';

const DashboardPage = lazy(() => import('./routes/dashboard'));

// Route configuration with lazy loading
route("dashboard", "routes/dashboard.tsx", {
  loader: () => import("./routes/dashboard.tsx").then(m => m.loader),
});
```

### Optimization Strategies
- Use `React.memo` for expensive components
- Implement virtual scrolling for large lists
- Optimize bundle size with dynamic imports
- Cache API responses with TanStack Query
- Use service workers for offline functionality

## Development Commands
- `pnpm dev`: Start development server
- `pnpm build`: Build for production
- `pnpm serve`: Preview production build
- `pnpm test`: Run unit tests
- `pnpm test:watch`: Run tests in watch mode
- `pnpm playwright:run-e2e`: Run end-to-end tests
- `pnpm lint`: Check code quality

## Best Practices
- Follow React Router V7 file-based routing conventions
- Implement proper error boundaries for route errors
- Use progressive enhancement patterns
- Maintain accessibility standards
- Optimize for performance with code splitting
- Handle loading states gracefully
- Implement proper form validation
- Use TypeScript strictly for type safety
- Test critical user journeys with Playwright
- Monitor bundle size and performance metrics