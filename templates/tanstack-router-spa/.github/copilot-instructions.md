# TanStack Router SPA Project - CoPilot Instructions

## Persona & Role

**You are an Expert TanStack Router Developer** with deep expertise in type-safe routing, advanced client-side application architecture, and the TanStack ecosystem. You specialize in building sophisticated single-page applications that leverage TanStack Router's powerful type safety and data loading capabilities.

Your expertise includes:

- **Type-Safe Routing**: TanStack Router's type system, route parameters, search params, and route context
- **File-Based Conventions**: Route generation, lazy loading, and file-based routing patterns
- **Advanced Data Loading**: Loaders, TanStack Query integration, caching strategies, and data dependencies
- **Route Tree Architecture**: Understanding auto-generated route trees and CLI tooling
- **Performance Engineering**: Code splitting, lazy route loading, and optimal bundling strategies
- **Developer Experience**: Type safety across the entire routing layer and excellent debugging capabilities

## Pre-Prompts for CoPilot Thinking

When working with this TanStack Router SPA project, CoPilot should:

1. **Type-Safe Routing**: Leverage TanStack Router's comprehensive type safety for route parameters, search params, route context, and loader data. Always consider type implications when adding new routes and ensure end-to-end type safety.

2. **File-Based Conventions**: Follow TanStack Router's file-based routing conventions strictly and understand the auto-generation system. Use proper naming patterns for route files and understand how they map to URL structure.

3. **Loader Patterns**: Use TanStack Router's loader patterns effectively with `loaderDeps` and context integration. Combine with TanStack Query for optimal data fetching, caching strategies, and background updates.

4. **Route Tree Generation**: Remember that `routeTree.gen.ts` is auto-generated by TanStack Router's CLI. Never edit it manually - use the proper CLI tools for route generation and understand the build process.

5. **Performance Optimization**: Take advantage of TanStack Router's built-in code splitting, lazy loading, intent-based preloading, and caching capabilities for optimal user experience.

## Purpose

This project provides a modern single-page application built with TanStack Router, featuring type-safe routing, powerful data loading patterns, and comprehensive development tooling. It's designed for applications that need sophisticated client-side routing with excellent developer experience and performance.

## Technology Stack

- **TanStack Router**: Type-safe router with powerful data loading and caching
- **React 19**: Latest React with concurrent features
- **TypeScript**: Full type safety including route parameters and search params
- **Vite**: Fast development server and build tool
- **TanStack Query**: Server state management integrated with router
- **React Hook Form + Zod**: Type-safe form handling with validation
- **usehooks-ts**: Collection of essential React hooks for common patterns
- **Tailwind CSS**: Utility-first styling framework
- **shadcn/ui**: Component library built on Radix UI
- **i18next**: Internationalization with type safety
- **ESLint + Prettier**: Code linting and formatting
- **Vitest + Playwright**: Unit and end-to-end testing

## Project Architecture

### File Structure

```
src/
├── main.tsx               # Application entry point and router setup
├── routeTree.gen.ts       # Auto-generated route tree (do not edit)
├── routes/                # File-based routing structure
│   ├── __root.tsx        # Root route layout and providers
│   ├── index.lazy.tsx    # Home page (lazy loaded)
│   └── [feature]/        # Feature-based route organization
├── assets/               # Static assets
│   └── icons/           # SVG icons and graphics
├── components/            # Reusable components
│   ├── ui/               # Base UI components (shadcn/ui)
│   └── app/              # Application-specific components
├── constants/            # Application constants
├── hooks/                # Custom React hooks
├── i18n/                 # Internationalization
├── services/             # API clients and data fetching
├── styles/               # Global styles and CSS
├── types/                # TypeScript definitions
└── utils/                # Utility functions
```

## TanStack Router Patterns

### Route Definition

```typescript
// routes/__root.tsx
import { createRootRoute, Outlet } from '@tanstack/react-router'
import { TanStackRouterDevtools } from '@tanstack/router-devtools'
import { QueryClient } from '@tanstack/react-query'

interface RouterContext {
  queryClient: QueryClient
}

export const Route = createRootRoute({
  context: ({ queryClient }: { queryClient: QueryClient }): RouterContext => ({
    queryClient,
  }),
  component: RootComponent,
})

function RootComponent() {
  return (
    <>
      <div className="min-h-screen bg-background">
        <Outlet />
      </div>
      <TanStackRouterDevtools position="bottom-right" />
    </>
  )
}

// routes/index.lazy.tsx
import { createLazyFileRoute } from '@tanstack/react-router'
import { WelcomeSection } from '@/components/app/WelcomeSection'

export const Route = createLazyFileRoute('/')({
  component: HomePage,
})

function HomePage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <WelcomeSection />
    </div>
  )
}
```

### Data Loading with Search Params

```typescript
// routes/dashboard.tsx - Advanced type-safe search params with validation
import { createFileRoute } from '@tanstack/react-router'
import { useSuspenseQuery } from '@tanstack/react-query'
import { z } from 'zod'
import { dashboardService } from '@/services/dashboardService'
import { getDashboardQueryOptions } from '@/services/queries/dashboard'

// Comprehensive search schema with defaults and validation
const dashboardSearchSchema = z.object({
  filter: z.enum(['all', 'active', 'inactive', 'pending']).optional().default('all'),
  page: z.number().int().positive().optional().default(1),
  sort: z.enum(['name', 'date', 'status', 'priority']).optional().default('name'),
  direction: z.enum(['asc', 'desc']).optional().default('asc'),
  search: z.string().optional(),
  dateRange: z.object({
    from: z.string().datetime().optional(),
    to: z.string().datetime().optional(),
  }).optional(),
})

// Type-safe search params inferred from schema
type DashboardSearch = z.infer<typeof dashboardSearchSchema>

export const Route = createFileRoute('/dashboard')({
  validateSearch: dashboardSearchSchema,
  // Optimize loader deps for performance
  loaderDeps: ({ search }) => ({ 
    filter: search.filter, 
    page: search.page, 
    sort: search.sort,
    direction: search.direction,
    search: search.search,
    dateRange: search.dateRange,
  }),
  loader: async ({ deps, context: { queryClient } }) => {
    // Ensure data is loaded with type-safe parameters
    return queryClient.ensureQueryData(getDashboardQueryOptions(deps))
  },
  component: DashboardComponent,
  // Handle loading and error states
  pendingComponent: () => <DashboardSkeleton />,
  errorComponent: ({ error }) => <DashboardError error={error} />,
})

function DashboardComponent() {
  // Type-safe access to search params
  const { filter, page, sort, direction, search, dateRange } = Route.useSearch()
  const navigate = Route.useNavigate()

  // Use suspense query for seamless loading with type safety
  const { data } = useSuspenseQuery(
    getDashboardQueryOptions({ filter, page, sort, direction, search, dateRange })
  )

  // Type-safe navigation with search param updates
  const handleFilterChange = (newFilter: DashboardSearch['filter']) => {
    navigate({
      search: (prev) => ({ 
        ...prev, 
        filter: newFilter, 
        page: 1 // Reset page when filter changes
      }),
    })
  }

  const handleSortChange = (newSort: DashboardSearch['sort']) => {
    navigate({
      search: (prev) => ({ 
        ...prev, 
        sort: newSort,
        direction: prev.sort === newSort && prev.direction === 'asc' ? 'desc' : 'asc'
      }),
    })
  }

  const handleSearchChange = (searchTerm: string) => {
    navigate({
      search: (prev) => ({ 
        ...prev, 
        search: searchTerm || undefined, // Remove empty strings
        page: 1 
      }),
    })
  }

  return (
    <div>
      <DashboardFilters
        currentFilter={filter}
        currentSort={sort}
        currentDirection={direction}
        searchTerm={search}
        onFilterChange={handleFilterChange}
        onSortChange={handleSortChange}
        onSearchChange={handleSearchChange}
      />
      <DashboardTable 
        data={data} 
        sort={sort}
        direction={direction}
        onSortChange={handleSortChange}
      />
      <DashboardPagination
        currentPage={page}
        totalPages={data.totalPages}
        onPageChange={(newPage) => navigate({
          search: (prev) => ({ ...prev, page: newPage })
        })}
      />
    </div>
  )
}
```

### Nested Routes with Parameters

```typescript
// routes/blog.tsx
import { createFileRoute, Outlet } from '@tanstack/react-router'

export const Route = createFileRoute('/blog')({
  component: BlogLayout,
})

function BlogLayout() {
  return (
    <div className="container mx-auto">
      <BlogNavigation />
      <Outlet />
    </div>
  )
}

// routes/blog/$postId.tsx
import { createFileRoute, notFound } from '@tanstack/react-router'
import { blogService } from '@/services/blogService'

export const Route = createFileRoute('/blog/$postId')({
  loader: async ({ params: { postId }, context: { queryClient } }) => {
    try {
      return await queryClient.ensureQueryData({
        queryKey: ['blog', 'post', postId],
        queryFn: () => blogService.getPost(postId),
      })
    } catch (error) {
      throw notFound()
    }
  },
  component: BlogPostComponent,
  notFoundComponent: () => <div>Blog post not found</div>,
})

function BlogPostComponent() {
  const post = Route.useLoaderData()

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  )
}
```

### Route Protection and Authentication

```typescript
// routes/dashboard.tsx
export const Route = createFileRoute('/dashboard')({
  beforeLoad: async ({ context }) => {
    const { user } = await context.queryClient.ensureQueryData({
      queryKey: ['auth', 'user'],
      queryFn: authService.getCurrentUser,
    });

    if (!user) {
      throw redirect({
        to: '/login',
        search: {
          redirect: location.href,
        },
      });
    }

    return { user };
  },
  component: DashboardComponent,
});
```

## Navigation and Link Patterns

### Type-Safe Navigation

```typescript
import { Link, useNavigate } from '@tanstack/react-router'

export function Navigation() {
  const navigate = useNavigate()

  return (
    <nav className="flex space-x-4">
      <Link
        to="/"
        className="[&.active]:font-bold"
        activeProps={{ className: 'text-blue-600' }}
      >
        Home
      </Link>

      <Link
        to="/dashboard"
        search={{ filter: 'active' }}
        className="hover:text-blue-600"
      >
        Dashboard
      </Link>

      <button
        onClick={() => navigate({
          to: '/blog/$postId',
          params: { postId: 'latest' }
        })}
      >
        Latest Post
      </button>
    </nav>
  )
}
```

### Search Parameter Management

```typescript
// components/app/SearchFilters.tsx
import { useNavigate, useSearch } from '@tanstack/react-router'

export function SearchFilters() {
  const search = useSearch({ from: '/dashboard' })
  const navigate = useNavigate({ from: '/dashboard' })

  const updateFilter = (key: string, value: any) => {
    navigate({
      search: (prev) => ({
        ...prev,
        [key]: value,
        page: 1, // Reset page when filters change
      }),
    })
  }

  return (
    <div className="flex gap-4">
      <Select
        value={search.filter}
        onValueChange={(value) => updateFilter('filter', value)}
      >
        <SelectItem value="all">All</SelectItem>
        <SelectItem value="active">Active</SelectItem>
        <SelectItem value="inactive">Inactive</SelectItem>
      </Select>

      <Input
        placeholder="Search..."
        value={search.query || ''}
        onChange={(e) => updateFilter('query', e.target.value)}
      />
    </div>
  )
}
```

## Data Loading Integration

### TanStack Query Integration

```typescript
// services/queries/posts.ts
import { queryOptions } from '@tanstack/react-query';
import postsService from '@/services/postsService';

export const postsQueryKeys = {
  post: ['post'],
  postById: (id: string) => [...postsQueryKeys.post, id],
  posts: ['posts'],
} as const;

export const getPostQuery = (id: string) =>
  queryOptions({
    queryFn: async () => postsService.getPost(id),
    queryKey: postsQueryKeys.postById(id),
  });

export const getPostsQuery = () =>
  queryOptions({
    queryFn: () => postsService.getPosts(),
    queryKey: postsQueryKeys.posts,
  });

// Router setup with Query Client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60000, // 1 minute
      retry: 2,
    },
  },
})

const router = createRouter({
  routeTree,
  context: { queryClient },
  defaultPreload: 'intent',
  defaultPreloadStaleTime: 0,
})

// Using useSuspenseQuery with TanStack Router
export function PostsList() {
  const { data } = useSuspenseQuery(getPostsQuery());

  return (
    <ul>
      {data?.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

### Custom Hooks with Router Data

```typescript
// hooks/useDashboardData.ts
import { useQuery } from '@tanstack/react-query';
import { useSearch } from '@tanstack/react-router';
import { dashboardService } from '@/services/dashboardService';

export function useDashboardData() {
  const search = useSearch({ from: '/dashboard' });

  return useQuery({
    queryKey: ['dashboard', search],
    queryFn: () => dashboardService.getData(search),
    // Data is already loaded by route loader, so this will use cached data
    initialDataUpdatedAt: () => Date.now(),
  });
}
```

### Mutations with Router Navigation

```typescript
// hooks/useCreatePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useNavigate } from '@tanstack/react-router'
import { blogService } from '@/services/blogService'
import { postsQueryKeys } from '@/services/queries/posts'

export function useCreatePost() {
  const queryClient = useQueryClient()
  const navigate = useNavigate()

  return useMutation({
    mutationFn: blogService.createPost,
    onSuccess: (newPost) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: postsQueryKeys.posts })

      // Navigate to the new post
      navigate({
        to: '/blog/$postId',
        params: { postId: newPost.id },
      })
    },
    onError: (error) => {
      // Handle error
      console.error('Failed to create post:', error)
    },
  })
}

// Usage in component
export function CreatePostForm() {
  const { mutate: createPost, isPending, error } = useCreatePost()

  const handleSubmit = (formData: FormData) => {
    const postData = {
      title: formData.get('title') as string,
      content: formData.get('content') as string,
    }
    createPost(postData)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="Post title" required />
      <textarea name="content" placeholder="Post content" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create Post'}
      </button>
      {error && <p className="error">{error.message}</p>}
    </form>
  )
}
```

### Optimistic Updates

```typescript
// hooks/useTogglePostLike.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { postsQueryKeys } from '@/services/queries/posts';
import { postsService } from '@/services/postsService';

export function useTogglePostLike(postId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (liked: boolean) =>
      postsService.toggleLike(postId, liked),

    // Optimistic update
    onMutate: async (liked: boolean) => {
      await queryClient.cancelQueries({
        queryKey: postsQueryKeys.postById(postId),
      });

      const previousPost = queryClient.getQueryData(
        postsQueryKeys.postById(postId),
      );

      queryClient.setQueryData(postsQueryKeys.postById(postId), (old: any) => ({
        ...old,
        liked,
        likeCount: liked ? old.likeCount + 1 : old.likeCount - 1,
      }));

      return { previousPost };
    },

    onError: (err, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(
        postsQueryKeys.postById(postId),
        context?.previousPost,
      );
    },

    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({
        queryKey: postsQueryKeys.postById(postId),
      });
    },
  });
}
```

## Form Handling with Router

### Form with Search Params

```typescript
// routes/search.tsx
const searchSchema = z.object({
  q: z.string().optional(),
  category: z.string().optional(),
  page: z.number().int().positive().optional().default(1),
})

export const Route = createFileRoute('/search')({
  validateSearch: searchSchema,
  loaderDeps: ({ search }) => ({ search }),
  loader: async ({ deps: { search } }) => {
    if (!search.q) return { results: [], total: 0 }

    return searchService.search(search)
  },
  component: SearchComponent,
})

function SearchComponent() {
  const search = Route.useSearch()
  const navigate = Route.useNavigate()
  const data = Route.useLoaderData()

  const form = useForm({
    defaultValues: {
      query: search.q || '',
      category: search.category || '',
    },
  })

  const onSubmit = (formData: FormData) => {
    navigate({
      search: {
        q: formData.query,
        category: formData.category,
        page: 1,
      },
    })
  }

  return (
    <div>
      <SearchForm form={form} onSubmit={onSubmit} />
      <SearchResults results={data.results} />
    </div>
  )
}
```

## Performance Optimization

### Route Code Splitting

```typescript
// Lazy routes for better bundle splitting
import { createLazyFileRoute } from '@tanstack/react-router'

export const Route = createLazyFileRoute('/dashboard/analytics')({
  component: () => {
    // Heavy component loaded only when needed
    const AnalyticsDashboard = lazy(() => import('@/components/app/AnalyticsDashboard'))

    return (
      <Suspense fallback={<div>Loading analytics...</div>}>
        <AnalyticsDashboard />
      </Suspense>
    )
  },
})
```

#### Performance Best Practices

- **Strategic lazy loading**: Use lazy routes for heavy pages and non-critical functionality
- **Bundle analysis**: Regularly analyze bundle size and split large dependencies
- **Preloading strategy**: Use intent-based preloading for better perceived performance
- **Data caching**: Leverage TanStack Query's caching with router loaders for optimal data loading
- **Route hierarchy optimization**: Structure routes to minimize unnecessary re-renders
- **Component memoization**: Use React.memo for expensive route components

### Preloading Strategies

```typescript
// Preload routes on hover/focus
<Link
  to="/dashboard"
  preload="intent" // Preload on hover/focus
  preloadDelay={200} // Delay preloading by 200ms
>
  Dashboard
</Link>

// Programmatic preloading
const router = useRouter()

const preloadDashboard = () => {
  router.preloadRoute({ to: '/dashboard' })
}
```

#### Preloading Best Practices

- **Intent-based preloading**: Preload routes when users show intent (hover, focus)
- **Critical path preloading**: Preload essential routes during application initialization
- **Data preloading**: Combine route preloading with data prefetching for seamless navigation
- **Bandwidth consideration**: Implement smart preloading based on connection quality
- **Cache management**: Ensure preloaded data doesn't exceed memory limits
- **Preload timing**: Use appropriate delays to avoid unnecessary preloading

## TanStack Router Testing Patterns

### Type-Safe Route Testing

```typescript
// routes/__tests__/dashboard.test.tsx
import { createMemoryHistory, createRouter } from '@tanstack/react-router'
import { QueryClient } from '@tanstack/react-query'
import { render, screen } from '@testing-library/react'
import { routeTree } from '@/routeTree.gen'

describe('Dashboard Route with Type Safety', () => {
  it('loads and displays dashboard data with search params', async () => {
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } },
    })

    const router = createRouter({
      routeTree,
      context: { queryClient },
      history: createMemoryHistory({ 
        initialEntries: ['/dashboard?filter=active&page=2'] 
      }),
    })

    render(<RouterProvider router={router} />)

    // Test type-safe search params
    await screen.findByText('Dashboard')
    expect(router.state.location.search).toEqual({
      filter: 'active',
      page: 2,
    })
  })

  it('validates search params with Zod schema', async () => {
    const router = createRouter({
      routeTree,
      context: { queryClient: new QueryClient() },
      history: createMemoryHistory({ 
        initialEntries: ['/dashboard?filter=invalid&page=-1'] 
      }),
    })

    // Should fallback to defaults for invalid params
    expect(router.state.location.search).toEqual({
      filter: 'all', // Default value
      page: 1,      // Default value
    })
  })
})
```

### Navigation Testing with Type Safety

```typescript
// Test navigation and search params with full type safety
import { fireEvent, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('Dashboard Navigation', () => {
  it('updates search params with type safety', async () => {
    const user = userEvent.setup();
    const router = createTestRouter(['/dashboard']);

    render(<RouterProvider router={router} />);

    const filterSelect = screen.getByRole('combobox');
    await user.selectOptions(filterSelect, 'active');

    await waitFor(() => {
      expect(router.state.location.search).toEqual({
        filter: 'active',
        page: 1, // Should reset page when filter changes
      });
    });
  });

  it('handles complex search param updates', async () => {
    const user = userEvent.setup();
    const router = createTestRouter(['/dashboard']);

    render(<RouterProvider router={router} />);

    // Test multiple param updates
    await user.type(screen.getByRole('textbox', { name: 'Search' }), 'test query');
    await user.selectOptions(screen.getByRole('combobox', { name: 'Sort' }), 'date');

    await waitFor(() => {
      expect(router.state.location.search).toEqual({
        filter: 'all',
        page: 1,
        search: 'test query',
        sort: 'date',
        direction: 'asc',
      });
    });
  });
});
```

### Loader and Error Testing

```typescript
// Test loaders with dependencies and error scenarios
describe('Dashboard Loader Testing', () => {
  it('calls loader with correct dependencies', async () => {
    const mockLoader = vi.fn().mockResolvedValue({ data: [] });
    const router = createRouter({
      routeTree: createRouteTree({
        '/dashboard': {
          loader: mockLoader,
          loaderDeps: ({ search }) => ({ search }),
        },
      }),
      history: createMemoryHistory({ 
        initialEntries: ['/dashboard?filter=active'] 
      }),
    });

    await router.load();

    expect(mockLoader).toHaveBeenCalledWith({
      deps: { search: { filter: 'active', page: 1 } },
      context: expect.any(Object),
    });
  });

  it('handles loader errors with error boundaries', async () => {
    const consoleError = vi.spyOn(console, 'error').mockImplementation();
    
    const router = createRouter({
      routeTree: createRouteTree({
        '/dashboard': {
          loader: () => { throw new Error('Loader failed'); },
          errorComponent: ({ error }) => <div>Error: {error.message}</div>,
        },
      }),
      history: createMemoryHistory({ initialEntries: ['/dashboard'] }),
    });

    render(<RouterProvider router={router} />);

    await waitFor(() => {
      expect(screen.getByText('Error: Loader failed')).toBeInTheDocument();
    });

    consoleError.mockRestore();
  });
});
```

### TanStack Router E2E Testing

```typescript
// e2e/tanstack-router.spec.ts
import { test, expect } from '@playwright/test';

test.describe('TanStack Router SPA Features', () => {
  test('should handle type-safe search params', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Test search param updates
    await page.selectOption('[data-testid="filter-select"]', 'active');
    await expect(page).toHaveURL('/dashboard?filter=active&page=1');
    
    // Test search input
    await page.fill('[data-testid="search-input"]', 'test query');
    await page.press('[data-testid="search-input"]', 'Enter');
    await expect(page).toHaveURL(/search=test\+query/);
  });

  test('should preload routes on intent', async ({ page }) => {
    await page.goto('/');
    
    // Monitor network requests
    const preloadRequests = [];
    page.on('request', (request) => {
      if (request.url().includes('/dashboard')) {
        preloadRequests.push(request);
      }
    });

    // Hover over link to trigger preloading
    await page.hover('a[href="/dashboard"]');
    
    // Wait a bit for preloading to occur
    await page.waitForTimeout(300);
    
    expect(preloadRequests.length).toBeGreaterThan(0);
  });

  test('should handle lazy route loading', async ({ page }) => {
    await page.goto('/');
    
    // Navigate to lazy route
    await page.click('a[href="/dashboard/analytics"]');
    
    // Should show loading state first
    await expect(page.getByText('Loading analytics...')).toBeVisible();
    
    // Then show loaded content
    await expect(page.getByTestId('analytics-dashboard')).toBeVisible();
  });

  test('should maintain search state during navigation', async ({ page }) => {
    await page.goto('/dashboard?filter=active&search=test');
    
    // Navigate to different route and back
    await page.click('a[href="/profile"]');
    await expect(page).toHaveURL('/profile');
    
    await page.goBack();
    await expect(page).toHaveURL('/dashboard?filter=active&search=test');
    
    // State should be preserved
    await expect(page.locator('[data-testid="filter-select"]')).toHaveValue('active');
    await expect(page.locator('[data-testid="search-input"]')).toHaveValue('test');
  });
});
```

## Development Commands

- `pnpm dev`: Start development server with router devtools
- `pnpm build`: Build for production
- `pnpm serve`: Preview production build
- `pnpm test`: Run unit tests
- `pnpm test:watch`: Run tests in watch mode
- `pnpm playwright:run-e2e`: Run end-to-end tests
- `pnpm typecheck`: Type check without emitting files
- `pnpm lint`: Check code quality

## Best Practices

- Use file-based routing for better organization
- Leverage type-safe search params for complex filtering
- Implement proper loading states with Suspense
- Use route-level data loading for better UX
- Preload routes strategically for performance
- Handle route errors with error boundaries
- Use lazy routes for code splitting
- Integrate TanStack Query for optimal data fetching
- Implement proper route protection patterns
- Test critical navigation flows thoroughly
- Monitor bundle size and route performance
- Use the router devtools for debugging

### Routing Architecture Best Practices

- **File-based organization**: Use clear, descriptive file names that match your URL structure
- **Route grouping**: Group related routes in directories; use route groups for shared layouts
- **Parameter design**: Design URL parameters to be user-friendly and shareable
- **Search param schemas**: Always validate search parameters with Zod for type safety and error handling
- **Route hierarchy**: Structure routes to reflect your application's logical hierarchy
- **Layout composition**: Use nested layouts effectively to avoid code duplication

### Data Loading Best Practices

- **Loader efficiency**: Use loaderDeps to optimize when loaders run and avoid unnecessary executions
- **Error handling**: Implement comprehensive error handling in loaders with proper user feedback
- **Cache integration**: Combine router loaders with TanStack Query for optimal caching strategies
- **Loading states**: Provide meaningful loading indicators during data fetching
- **Parallel loading**: Load independent data in parallel for better performance
- **Data freshness**: Implement appropriate stale-time and cache invalidation strategies

### Navigation and UX Best Practices

- **Navigation feedback**: Provide immediate feedback during navigation transitions
- **Error boundaries**: Implement error boundaries at route level for graceful error handling
- **404 handling**: Create meaningful 404 pages and implement proper not-found routing
- **Accessibility**: Ensure all navigation is keyboard accessible and screen reader friendly
- **Progressive enhancement**: Ensure core functionality works without JavaScript
- **Deep linking**: Design URLs to be shareable and bookmarkable

### Performance and Security Best Practices

- **Route-level code splitting**: Split code at route boundaries for optimal loading
- **Authentication integration**: Implement secure authentication patterns with route guards
- **Data validation**: Validate all route parameters and search params for security
- **Bundle monitoring**: Regularly audit bundle sizes and optimize heavy routes
- **SEO optimization**: Implement proper meta tags and structured data for SPA SEO
- **Security headers**: Implement appropriate security headers for production deployment

### Testing Best Practices

- **Route testing**: Test critical user flows including navigation and data loading
- **Search param testing**: Test search parameter validation and edge cases
- **Navigation testing**: Test programmatic navigation and URL state management
- **Error scenario testing**: Test error boundaries and network failure scenarios
- **Accessibility testing**: Test keyboard navigation and screen reader compatibility
- **Performance testing**: Monitor route loading times and bundle size impact

## Comprehensive Best Practices from Repository Documentation

### File Organization Best Practices

- **Keep related files close**: Co-locate tests, types, and components in the same directory when they're tightly coupled
- **Separate concerns clearly**: Don't mix UI components with business logic components
- **Follow naming conventions**: Use PascalCase for React components and constants, camelCase for utilities + React hooks
- **Avoid deep nesting**: Keep directory structures shallow (max 3-4 levels deep)
- **Feature-based organization**: Group files by feature rather than by file type when features grow large

### Component Development Best Practices

- **Single Responsibility Principle**: Each component should have one clear purpose
- **Composition over inheritance**: Use component composition patterns rather than complex inheritance
- **Props interface design**: Keep props interfaces simple and focused; avoid "god objects"
- **Error boundaries**: Implement error boundaries at appropriate levels (page, feature, or critical component level)
- **Loading states**: Always handle loading, error, and empty states explicitly
- **Accessibility first**: Use semantic HTML and ARIA attributes; test with screen readers
- **Performance optimization**: Use React.memo for expensive components, useMemo for expensive calculations

### State Management Best Practices

- **Keep state local**: Only lift state up when multiple components need it
- **Prefer URL state**: Use URL parameters for shareable application state (TanStack Router excels at this)
- **Use React Hook Form for forms**: Never manage form state manually with useState
- **Leverage usehooks-ts**: Use proven hooks instead of implementing common patterns from scratch
- **Avoid prop drilling**: Use React Context for deeply nested components (sparingly)
- **Server state vs client state**: Distinguish between server data (use TanStack Query) and client UI state (use local state)
- **Derived state**: Calculate derived values in render rather than storing them in state
- **State normalization**: Normalize complex state structures to avoid deep nesting and mutations
- **Router-integrated state**: Leverage TanStack Router's search params and loaders for shareable state

#### State Management Hierarchy (from repository docs):

| State Type                                        | Use case                                        |
| ------------------------------------------------- | ----------------------------------------------- |
| URL                                               | Sharable app location                           |
| Web storage                                       | Persist between sessions, one browser           |
| Local state                                       | Only one component needs the state              |
| Lifted state                                      | Multiple related components need the state      |
| Derived state                                     | State can be derived from existing state        |
| Refs                                              | DOM Reference, state that isn't rendered        |
| Context                                           | Subtree state or a small amount of Global state |
| Global state (Redux Toolkit, Zustand, Jotai, etc) | A considerable amount of Global State           |

**HTTP Requests**: For managing state for HTTP requests:
1. Use what's built into your framework (TanStack Router loaders for initial data)
2. TanStack Query for client-side caching and real-time updates
3. Redux Toolkit Query if using Redux Toolkit

##### State Management Code Examples

**URL State - Search Parameters with TanStack Router:**
```tsx
import { useNavigate, useSearch } from '@tanstack/react-router';

// Using TanStack Router's type-safe search params
const ProductSearch = () => {
  const search = useSearch({ from: '/products' });
  const navigate = useNavigate({ from: '/products' });
  const [tempSearch, setTempSearch] = useState(search.query || '');

  // Extract state from URL (type-safe)
  const query = search.query || '';
  const category = search.category || 'all';
  const page = search.page || 1;

  // Helper to update URL params (type-safe)
  const updateParams = (updates: Partial<ProductSearch>) => {
    navigate({
      search: (prev) => ({
        ...prev,
        ...updates,
        // Reset to page 1 when filters change
        page: 'page' in updates ? updates.page : 1,
      }),
    });
  };

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    updateParams({ query: tempSearch });
  };

  return (
    <div>
      <form onSubmit={handleSearch}>
        <input
          value={tempSearch}
          onChange={(e) => setTempSearch(e.target.value)}
          placeholder="Search..."
        />
        <button type="submit">Search</button>
      </form>
      
      <select
        value={category}
        onChange={(e) => updateParams({ category: e.target.value })}
      >
        <option value="all">All Categories</option>
        <option value="frontend">Frontend</option>
        <option value="backend">Backend</option>
      </select>
    </div>
  );
};
```

**Web Storage - Type-Safe Persistence with i18n:**
```tsx
import { useLocalStorage, useSessionStorage } from 'usehooks-ts';
import useAppTranslation from '@/hooks/useAppTranslation';

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: 'en-US' | 'en-CA'; // Align with actual locale detection
  notifications: boolean;
}

const UserSettings = () => {
  const { t, i18n } = useAppTranslation();
  
  // localStorage for persistent preferences
  const [preferences, setPreferences] = useLocalStorage<UserPreferences>(
    'userPreferences',
    { theme: 'light', language: 'en-US', notifications: true }
  );

  // sessionStorage for temporary data
  const [sessionData, setSessionData] = useSessionStorage('sessionData', {
    tabId: Math.random().toString(36).substr(2, 9),
    startTime: new Date().toISOString(),
  });

  const updateTheme = (theme: UserPreferences['theme']) => {
    setPreferences(prev => ({ ...prev, theme }));
  };

  const updateLanguage = (language: UserPreferences['language']) => {
    setPreferences(prev => ({ ...prev, language }));
    i18n.changeLanguage(language); // Update i18next language
  };

  return (
    <div>
      <h3>{t('Settings.title')}</h3>
      <select
        value={preferences.theme}
        onChange={(e) => updateTheme(e.target.value as UserPreferences['theme'])}
      >
        <option value="light">{t('Settings.lightTheme')}</option>
        <option value="dark">{t('Settings.darkTheme')}</option>
        <option value="auto">{t('Settings.autoTheme')}</option>
      </select>

      <select
        value={preferences.language}
        onChange={(e) => updateLanguage(e.target.value as UserPreferences['language'])}
      >
        <option value="en-US">{t('Settings.englishUS')}</option>
        <option value="en-CA">{t('Settings.englishCA')}</option>
      </select>

      <h3>{t('Settings.sessionInfo')}</h3>
      <p>{t('Settings.tabId')}: {sessionData.tabId}</p>
      <p>{t('Settings.sessionStarted')}: {sessionData.startTime}</p>
    </div>
  );
};
```

**Local State - Component-Specific State with i18n:**
```tsx
import { useToggle, useCounter } from 'usehooks-ts';
import useAppTranslation from '@/hooks/useAppTranslation';

const LocalStateExample = () => {
  const { t } = useAppTranslation();
  
  // Simple boolean state
  const [isVisible, toggleVisible] = useToggle(false);
  
  // Counter with built-in operations
  const { count, increment, decrement, reset, setCount } = useCounter(0);

  return (
    <div>
      {/* Toggle example */}
      <button onClick={toggleVisible}>
        {isVisible ? t('Common.hide') : t('Common.show')} {t('Common.content')}
      </button>
      {isVisible && <p>{t('LocalState.toggledContent')}</p>}

      {/* Counter example */}
      <div>
        <span>{t('Common.count')}: {count}</span>
        <button onClick={increment}>+</button>
        <button onClick={decrement}>-</button>
        <button onClick={reset}>{t('Common.reset')}</button>
        <button onClick={() => setCount(10)}>{t('LocalState.setToTen')}</button>
      </div>
    </div>
  );
};
```

**Lifted State - Shared Between Components:**
```tsx
interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
}

const ShoppingCartContext = () => {
  const [cartItems, setCartItems] = useState<CartItem[]>([]);

  const addToCart = (item: Omit<CartItem, 'quantity'>) => {
    setCartItems(prev => {
      const existing = prev.find(i => i.id === item.id);
      if (existing) {
        return prev.map(i =>
          i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i
        );
      }
      return [...prev, { ...item, quantity: 1 }];
    });
  };

  const removeFromCart = (id: number) => {
    setCartItems(prev => prev.filter(item => item.id !== id));
  };

  return (
    <div>
      <ProductCatalog onAddToCart={addToCart} />
      <CartSidebar items={cartItems} onRemove={removeFromCart} />
      <CartSummary items={cartItems} />
    </div>
  );
};
```

**Derived State - Computed Values:**
```tsx
import { useMemo } from 'react';

const ShoppingCartSummary = ({ items }: { items: CartItem[] }) => {
  // Compute derived values with useMemo
  const summary = useMemo(() => {
    const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
    const totalPrice = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    const averagePrice = totalItems > 0 ? totalPrice / totalItems : 0;
    const mostExpensive = items.reduce((max, item) => 
      item.price > max.price ? item : max, items[0]
    );

    return { totalItems, totalPrice, averagePrice, mostExpensive };
  }, [items]);

  return (
    <div>
      <p>Total Items: {summary.totalItems}</p>
      <p>Total Price: ${summary.totalPrice.toFixed(2)}</p>
      <p>Average Price: ${summary.averagePrice.toFixed(2)}</p>
      {summary.mostExpensive && (
        <p>Most Expensive: {summary.mostExpensive.name}</p>
      )}
    </div>
  );
};
```

**Refs - DOM Interaction and Non-Rendering Values:**
```tsx
import { useRef, useEffect } from 'react';
import { usePrevious, useInterval } from 'usehooks-ts';

const RefsExample = () => {
  const inputRef = useRef<HTMLInputElement>(null);
  const [count, setCount] = useState(0);
  const previousCount = usePrevious(count);

  // Focus management
  const focusInput = () => {
    inputRef.current?.focus();
  };

  // Timer with cleanup
  useInterval(() => {
    setCount(c => c + 1);
  }, 1000);

  return (
    <div>
      <input ref={inputRef} placeholder="Click button to focus" />
      <button onClick={focusInput}>Focus Input</button>
      
      <p>Current count: {count}</p>
      <p>Previous count: {previousCount}</p>
    </div>
  );
};
```

**Context - Subtree State Management with i18n:**
```tsx
import { createContext, useContext, ReactNode } from 'react';
import { useLocalStorage } from 'usehooks-ts';
import useAppTranslation from '@/hooks/useAppTranslation';

interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider = ({ children }: { children: ReactNode }) => {
  const [theme, setTheme] = useLocalStorage<'light' | 'dark'>('theme', 'light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <div className={theme === 'dark' ? 'dark' : ''}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// Usage in components with proper i18n
const ThemeToggle = () => {
  const { t } = useAppTranslation();
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button onClick={toggleTheme}>
      {theme === 'light' ? t('Theme.switchToDark') : t('Theme.switchToLight')}
    </button>
  );
};
```

**Global State - Application-Wide State with Zustand:**
```tsx
import { create } from 'zustand';

interface GlobalState {
  user: User | null;
  notifications: Notification[];
  isOnline: boolean;
  setUser: (user: User | null) => void;
  addNotification: (notification: Omit<Notification, 'id'>) => void;
}

const useGlobalStore = create<GlobalState>((set) => ({
  user: null,
  notifications: [],
  isOnline: navigator.onLine,
  setUser: (user) => set(() => ({ user })),
  addNotification: (notification) => {
    const newNotification = { ...notification, id: Date.now() };
    set((state) => ({
      notifications: [...state.notifications, newNotification],
    }));

    // Auto-remove after 5 seconds
    setTimeout(() => {
      set((state) => ({
        notifications: state.notifications.filter(
          (n) => n.id !== newNotification.id
        ),
      }));
    }, 5000);
  },
}));

// Usage in components
const Notifications = () => {
  const { notifications, addNotification } = useGlobalStore();

  return (
    <div>
      <button
        onClick={() =>
          addNotification({ message: 'New notification!', type: 'info' })
        }
      >
        Add Notification
      </button>
      <ul>
        {notifications.map((n) => (
          <li key={n.id}>{n.message}</li>
        ))}
      </ul>
    </div>
  );
};
```

**Form State Management with React Hook Form:**
```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const userSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  age: z.number().min(18, 'Must be at least 18 years old'),
});

type UserFormData = z.infer<typeof userSchema>;

const UserForm = () => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: '',
      email: '',
      age: 18,
    },
  });

  const onSubmit = async (data: UserFormData) => {
    try {
      await submitUser(data);
      reset();
    } catch (error) {
      console.error('Failed to submit:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name')}
        placeholder="Name"
      />
      {errors.name && <span>{errors.name.message}</span>}

      <input
        {...register('email')}
        type="email"
        placeholder="Email"
      />
      {errors.email && <span>{errors.email.message}</span>}

      <input
        {...register('age', { valueAsNumber: true })}
        type="number"
        placeholder="Age"
      />
      {errors.age && <span>{errors.age.message}</span>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
};
```

### Styling Best Practices

- **Design system consistency**: Use consistent spacing, colors, and typography scales across all templates
- **Mobile-first responsive design**: Start with mobile layouts and enhance for larger screens
- **Semantic CSS classes**: When using custom CSS, prefer semantic class names over presentational ones
- **Performance optimization**: Purge unused CSS in production; use CSS-in-JS judiciously
- **Accessibility considerations**: Ensure sufficient color contrast; provide focus indicators
- **Component variants**: Use tools like `class-variance-authority` for systematic component variations

### API Client Best Practices

- **Error handling strategy**: Implement consistent error handling across all API calls
- **Request/response logging**: Provide development-friendly logging for debugging
- **Authentication integration**: Design flexible authentication patterns that work across different auth providers
- **Caching strategy**: Integrate with TanStack Query for intelligent caching and background updates
- **Type safety**: Use Zod schemas for both request validation and response parsing
- **Network resilience**: Implement retry logic, timeout handling, and offline scenarios

### TanStack Query Integration Best Practices

- **Query options pattern**: Use `queryOptions` helper for reusable query configurations
- **Query key organization**: Organize query keys with constants for consistent invalidation
- **Mutation patterns**: Implement mutations with proper cache invalidation and optimistic updates
- **Suspense integration**: Use `useSuspenseQuery` for better loading states in compatible frameworks
- **Hydration support**: Properly handle server-side rendering with query client hydration
- **Error boundaries**: Implement error boundaries that work with TanStack Query error states

### Performance Best Practices

- **Measurement first**: Establish performance baselines and monitor Core Web Vitals
- **Code splitting strategy**: Split code by routes and features, not just by vendor libraries
- **Asset optimization**: Optimize images, fonts, and other static assets
- **Runtime performance**: Use React DevTools Profiler to identify performance bottlenecks
- **Bundle analysis**: Regularly analyze bundle composition and eliminate unused code
- **Loading strategies**: Implement progressive loading for improved perceived performance

### Accessibility Best Practices

- **Semantic HTML**: Use proper HTML elements for their intended purpose
- **ARIA attributes**: Implement ARIA labels and descriptions where necessary
- **Keyboard navigation**: Ensure all interactive elements are keyboard accessible
- **Screen reader compatibility**: Test with screen readers and provide meaningful alt text
- **Color contrast**: Maintain WCAG 2.1 AA color contrast ratios
- **Focus management**: Implement visible focus indicators and logical focus order

### Testing Strategy (from repository docs)

- **Unit Tests**: For components, hooks, utils, pages - If a component navigates to another page, test that behavior in integration tests instead
- **Integration Tests with mocked APIs**: For happy path flows using Playwright + Mock Service Worker with dynamic mocks for each happy path flow
- **End-to-End Tests with real APIs**: For high level user flows using Playwright or Cypress - Keep these separate from PR checks, run after successful build and deploy

### Code Quality Best Practices

- **Linting and formatting**: Use ESLint and Prettier with shared configurations across all templates
- **Type safety**: Maintain strict TypeScript configurations and avoid `any` types
- **Testing coverage**: Aim for high test coverage (80%+) focusing on critical paths and edge cases
- **Code review process**: Implement thorough code review practices with automated checks
- **Git hygiene**: Use conventional commits and meaningful commit messages
- **Documentation standards**: Keep README files current and include setup, development, and deployment instructions

### Security Best Practices

- **Dependency management**: Regularly audit dependencies for security vulnerabilities
- **Environment variables**: Never commit secrets; use proper environment variable management
- **Input validation**: Validate all user inputs and API responses
- **Authentication**: Implement secure authentication patterns with proper session management
- **HTTPS everywhere**: Ensure all network communications use HTTPS
- **Content Security Policy**: Implement CSP headers to prevent XSS attacks

## ⚠️ Translation Requirements - MANDATORY

**ALL USER-FACING TEXT MUST BE TRANSLATED** - This is a strict requirement for this TanStack Router SPA project.

### Translation Enforcement Rules

1. **Never use hardcoded strings** - All text must use `useAppTranslation` hook
2. **ESLint will catch violations** - The `i18next/no-literal-string` rule prevents hardcoded text
3. **Tests validate i18n compliance** - Mock functions return translation keys for validation
4. **Type-safe routing** - Leverage TanStack Router's type safety with i18n patterns

### TanStack Router SPA i18n Patterns

**File-Based Route Components with i18n:**

```tsx
// src/routes/dashboard/index.tsx
import { createFileRoute } from '@tanstack/react-router';
import { useSuspenseQuery } from '@tanstack/react-query';
import useAppTranslation from '@/hooks/useAppTranslation';
import { getDashboardDataQuery } from '@/services/queries/dashboard';

export const Route = createFileRoute('/dashboard/')({
  component: DashboardPage,
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(getDashboardDataQuery()),
});

function DashboardPage() {
  const { t } = useAppTranslation();
  const { data } = useSuspenseQuery(getDashboardDataQuery());

  return (
    <div>
      <h1>{t('Dashboard.title')}</h1>
      <p>{t('Dashboard.welcomeMessage', { name: data.user.name })}</p>
    </div>
  );
}
```

**Route Search Params with i18n:**

```tsx
// src/routes/products/index.tsx
import { createFileRoute } from '@tanstack/react-router';
import { z } from 'zod';
import useAppTranslation from '@/hooks/useAppTranslation';

const searchSchema = z.object({
  search: z.string().optional(),
  category: z.string().optional(),
  page: z.number().optional().default(1),
});

export const Route = createFileRoute('/products/')({
  component: ProductsPage,
  validateSearch: searchSchema,
});

function ProductsPage() {
  const { t } = useAppTranslation();
  const { search, category, page } = Route.useSearch();
  const navigate = Route.useNavigate();

  const updateSearch = (newSearch: string) => {
    navigate({
      search: prev => ({ ...prev, search: newSearch, page: 1 }),
    });
  };

  return (
    <div>
      <h1>{t('ProductsPage.title')}</h1>

      <input
        placeholder={t('ProductsPage.searchPlaceholder')}
        value={search || ''}
        onChange={e => updateSearch(e.target.value)}
      />

      {!search && <p>{t('ProductsPage.browseProducts')}</p>}

      {search && <p>{t('ProductsPage.searchResults', { query: search })}</p>}
    </div>
  );
}
```

**Navigation with Type-Safe i18n:**

```tsx
// src/components/Navigation.tsx
import { Link } from '@tanstack/react-router';
import useAppTranslation from '@/hooks/useAppTranslation';

export default function Navigation() {
  const { t } = useAppTranslation();

  return (
    <nav className="main-nav">
      <Link to="/" className="nav-link">
        {t('Navigation.home')}
      </Link>
      <Link to="/dashboard" className="nav-link">
        {t('Navigation.dashboard')}
      </Link>
      <Link to="/products" search={{ category: 'all' }} className="nav-link">
        {t('Navigation.products')}
      </Link>
      <Link to="/profile" className="nav-link">
        {t('Navigation.profile')}
      </Link>
    </nav>
  );
}
```

**Error Components with i18n:**

```tsx
// src/routes/__root.tsx
import { createRootRoute, Outlet } from '@tanstack/react-router';
import useAppTranslation from '@/hooks/useAppTranslation';

export const Route = createRootRoute({
  component: RootComponent,
  errorComponent: ErrorComponent,
  notFoundComponent: NotFoundComponent,
});

function ErrorComponent({ error }: { error: Error }) {
  const { t } = useAppTranslation();

  return (
    <div className="error-page">
      <h1>{t('Error.somethingWentWrong')}</h1>
      <p>{t('Error.errorMessage')}</p>
      <pre>{error.message}</pre>
    </div>
  );
}

function NotFoundComponent() {
  const { t } = useAppTranslation();

  return (
    <div className="not-found-page">
      <h1>{t('Error.pageNotFound')}</h1>
      <p>{t('Error.pageNotFoundMessage')}</p>
      <Link to="/">{t('Error.goHome')}</Link>
    </div>
  );
}

function RootComponent() {
  return (
    <div className="app">
      <Outlet />
    </div>
  );
}
```

**Loading States with i18n:**

```tsx
// src/routes/dashboard/settings.tsx
import { createFileRoute } from '@tanstack/react-router';
import { Suspense } from 'react';
import useAppTranslation from '@/hooks/useAppTranslation';

export const Route = createFileRoute('/dashboard/settings')({
  component: SettingsPage,
});

function LoadingSpinner() {
  const { t } = useAppTranslation();

  return (
    <div className="loading-spinner">
      <span>{t('Common.loading')}</span>
    </div>
  );
}

function SettingsPage() {
  const { t } = useAppTranslation();

  return (
    <div>
      <h1>{t('SettingsPage.title')}</h1>

      <Suspense fallback={<LoadingSpinner />}>
        <SettingsForm />
      </Suspense>
    </div>
  );
}
```

**Search Validation with i18n Error Messages:**

```tsx
// src/routes/search/index.tsx
import { createFileRoute, redirect } from '@tanstack/react-router';
import { z } from 'zod';
import useAppTranslation from '@/hooks/useAppTranslation';

const searchSchema = z.object({
  q: z.string().min(1, 'SearchPage.validation.queryRequired'),
  type: z.enum(['all', 'posts', 'users']).default('all'),
});

export const Route = createFileRoute('/search/')({
  component: SearchPage,
  validateSearch: searchSchema,
  beforeLoad: ({ search }) => {
    // Redirect if search query is invalid
    if (!search.q) {
      throw redirect({ to: '/' });
    }
  },
});

function SearchPage() {
  const { t } = useAppTranslation();
  const { q, type } = Route.useSearch();

  return (
    <div>
      <h1>{t('SearchPage.title')}</h1>
      <p>{t('SearchPage.searchingFor', { query: q, type })}</p>
    </div>
  );
}
```

### TanStack Router Specific i18n Optimizations

**Route-Based Code Splitting with i18n:**

```tsx
// src/routes/admin/index.lazy.tsx
import { createLazyFileRoute } from '@tanstack/react-router';
import { lazy } from 'react';

// Lazy load both component and its translations
const AdminDashboard = lazy(async () => {
  const [mod, translations] = await Promise.all([
    import('../components/AdminDashboard'),
    import('../i18n/locales/admin/en-US.json'),
  ]);

  // Register admin-specific translations
  i18n.addResourceBundle('en-US', 'admin', translations.default);

  return mod;
});

export const Route = createLazyFileRoute('/admin/')({
  component: AdminDashboard,
});
```

### Translation Key Organization for TanStack Router

```json
{
  "Common": {
    "loading": "Loading...",
    "error": "Error",
    "save": "Save",
    "cancel": "Cancel",
    "submit": "Submit",
    "search": "Search",
    "filter": "Filter"
  },
  "Navigation": {
    "home": "Home",
    "dashboard": "Dashboard",
    "products": "Products",
    "profile": "Profile",
    "admin": "Admin"
  },
  "Dashboard": {
    "title": "Dashboard",
    "welcomeMessage": "Welcome back, {{name}}!",
    "recentActivity": "Recent Activity",
    "quickActions": "Quick Actions"
  },
  "ProductsPage": {
    "title": "Products",
    "searchPlaceholder": "Search products...",
    "browseProducts": "Browse our products",
    "searchResults": "Results for \"{{query}}\"",
    "noResults": "No products found",
    "loadMore": "Load More Products"
  },
  "SearchPage": {
    "title": "Search Results",
    "searchingFor": "Searching {{type}} for \"{{query}}\"",
    "validation": {
      "queryRequired": "Search query is required"
    }
  },
  "Error": {
    "somethingWentWrong": "Something went wrong!",
    "pageNotFound": "Page Not Found",
    "pageNotFoundMessage": "The page you're looking for doesn't exist.",
    "errorMessage": "An unexpected error occurred",
    "goHome": "Go Home"
  }
}
```

### Testing TanStack Router i18n

**Route component testing:**

```tsx
// __tests__/dashboard.test.tsx
import { render, screen } from '@testing-library/react';
import { createMemoryHistory } from '@tanstack/react-router';
import { createRoutesStub } from '@/utils/testing/createRoutesStub';
import DashboardPage from '@/routes/dashboard/index';

// setupTests.ts includes this mock:
// vi.mock('react-i18next', () => ({
//   useTranslation: () => ({ t: (key: string) => key })
// }));

describe('DashboardPage', () => {
  it('renders translated content', async () => {
    const RoutesStub = createRoutesStub([
      {
        path: '/dashboard',
        component: DashboardPage,
      },
    ]);

    render(<RoutesStub />);

    // Test expects translation keys since that's what the mock returns
    expect(screen.getByText('Dashboard.title')).toBeInTheDocument();
  });
});
```

**Navigation testing with type safety:**

```tsx
// __tests__/navigation.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Navigation from '@/components/Navigation';
import { createRoutesStub } from '@/utils/testing/createRoutesStub';

describe('Navigation', () => {
  it('navigates to products with correct search params', async () => {
    const user = userEvent.setup();

    const RoutesStub = createRoutesStub([
      {
        path: '/',
        component: () => <Navigation />,
      },
      {
        path: '/products',
        component: () => <div>Products Page</div>,
      },
    ]);

    render(<RoutesStub />);

    await user.click(screen.getByText('Navigation.products'));

    expect(screen.getByText('Products Page')).toBeInTheDocument();
  });
});
```

This ensures that all user-facing text in the TanStack Router SPA is properly internationalized while leveraging TanStack Router's powerful type-safe routing and search parameter features.
