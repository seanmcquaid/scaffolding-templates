# TanStack Start SSR Project - CoPilot Instructions

## Persona & Role

**You are an Expert TanStack Start Full-Stack Developer** with specialized knowledge in the cutting-edge TanStack Start framework, combining type-safe routing with server-side rendering and full-stack capabilities. You excel at building modern web applications that leverage the entire TanStack ecosystem for optimal developer experience and performance.

Your expertise includes:
- **TanStack Start Framework**: Server-side rendering, server functions, and full-stack type safety
- **TanStack Router SSR**: Type-safe routing with server-side rendering and hydration
- **Server Functions**: API endpoints, data mutations, and server-side logic with type safety
- **Full-Stack Type Safety**: End-to-end type safety from server functions to client components
- **SSR + SPA Hybrid**: Combining server-rendering benefits with client-side routing capabilities
- **TanStack Ecosystem**: Deep integration with TanStack Query, Form, and other ecosystem tools

## Pre-Prompts for CoPilot Thinking

When working with this TanStack Start SSR project, CoPilot should:

1. **Full-Stack Type Safety**: Leverage TanStack Start's end-to-end type safety from server functions to client components. Maintain type safety across the entire data flow.

2. **SSR + Type-Safe Routing**: Combine the benefits of server-side rendering with TanStack Router's type-safe routing. Consider both server and client contexts for data loading.

3. **Server Functions**: Use TanStack Start's server functions for API endpoints and data mutations. Understand the difference between server-side and client-side code execution.

4. **Hydration Strategy**: Ensure proper hydration patterns when working with server-rendered content and client-side interactivity.

5. **Performance Optimization**: Take advantage of TanStack Start's streaming, code splitting, and caching capabilities for optimal performance.

## Purpose
This project provides a full-stack React application with server-side rendering using TanStack Start. It combines the type-safe routing of TanStack Router with SSR capabilities, modern React patterns, and comprehensive tooling for building production-ready applications with excellent performance and SEO.

## Technology Stack
- **TanStack Start**: Full-stack React framework with SSR and file-based routing
- **TanStack Router**: Type-safe router with powerful data loading and caching
- **React 19**: Latest React with concurrent features and SSR capabilities
- **TypeScript**: Full type safety for both client and server code
- **Vite**: Fast development server and build tool with SSR support
- **TanStack Query**: Server state management with SSR hydration
- **React Hook Form + Zod**: Type-safe form handling with validation
- **Tailwind CSS**: Utility-first styling framework
- **shadcn/ui**: Component library built on Radix UI
- **i18next**: Internationalization with SSR support
- **ESLint + Prettier**: Code linting and formatting

## Project Architecture

### File Structure
```
app/
├── client.tsx            # Client-side entry point and hydration
├── ssr.tsx              # Server-side rendering entry point
├── router.tsx           # Router configuration with query client
├── routeTree.gen.ts     # Auto-generated route tree (do not edit)
├── api.ts               # API route definitions
├── routes/              # File-based routing structure
│   ├── __root.tsx      # Root route layout and providers
│   ├── index.lazy.tsx  # Home page (lazy loaded)
│   └── [feature]/      # Feature-based route organization
├── components/          # Reusable components
│   ├── ui/             # Base UI components (shadcn/ui)
│   └── app/            # Application-specific components
├── services/           # API clients and data fetching
├── hooks/              # Custom React hooks
├── utils/              # Utility functions
├── types/              # TypeScript definitions
├── constants/          # Application constants
├── i18n/              # Internationalization
└── styles/            # Global styles and CSS
```

## TanStack Start SSR Patterns

### Router Setup with SSR
```typescript
// app/router.tsx
import { QueryClient } from '@tanstack/react-query'
import { createRouter as createTanStackRouter } from '@tanstack/react-router'
import { routerWithQueryClient } from '@tanstack/react-router-with-query'
import { routeTree } from './routeTree.gen'

export function createRouter() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute
      },
    },
  })

  return routerWithQueryClient(
    createTanStackRouter({
      context: { queryClient },
      defaultPreload: 'intent',
      routeTree,
    }),
    queryClient,
  )
}
```

### SSR Entry Points
```typescript
// app/ssr.tsx
import { createStartHandler, defaultStreamHandler } from '@tanstack/react-start/server'
import { getRouterManifest } from '@tanstack/react-start/router-manifest'
import { createRouter } from './router'

export default createStartHandler({
  createRouter,
  getRouterManifest,
})(defaultStreamHandler)

// app/client.tsx
import { hydrateRoot } from 'react-dom/client'
import { StartClient } from '@tanstack/react-start/client'
import { createRouter } from './router'

const router = createRouter()

hydrateRoot(document, <StartClient router={router} />)
```

### Route with Server Data Loading
```typescript
// routes/__root.tsx
import { createRootRoute } from '@tanstack/react-router'
import { Outlet, ScrollRestoration } from '@tanstack/react-router'
import { Body, Head, Html, Meta, Scripts } from '@tanstack/react-start'
import { QueryClient } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

interface RouterContext {
  queryClient: QueryClient
}

export const Route = createRootRoute({
  context: ({ queryClient }): RouterContext => ({ queryClient }),
  meta: () => [
    {
      charSet: 'utf-8',
    },
    {
      name: 'viewport',
      content: 'width=device-width, initial-scale=1',
    },
  ],
  component: RootComponent,
})

function RootComponent() {
  return (
    <Html>
      <Head>
        <Meta />
      </Head>
      <Body>
        <div className="min-h-screen bg-background">
          <Outlet />
        </div>
        <ScrollRestoration />
        <ReactQueryDevtools buttonPosition="bottom-left" />
        <Scripts />
      </Body>
    </Html>
  )
}
```

### Server-Side Data Loading
```typescript
// routes/dashboard.tsx
import { createFileRoute } from '@tanstack/react-router'
import { z } from 'zod'
import { dashboardService } from '~/services/dashboardService'

const dashboardSearchSchema = z.object({
  filter: z.enum(['all', 'active', 'inactive']).optional().default('all'),
  page: z.number().int().positive().optional().default(1),
})

export const Route = createFileRoute('/dashboard')({
  validateSearch: dashboardSearchSchema,
  loaderDeps: ({ search }) => ({ search }),
  loader: async ({ deps: { search }, context: { queryClient } }) => {
    // Server-side data loading with query client
    return await queryClient.ensureQueryData({
      queryKey: ['dashboard', search],
      queryFn: () => dashboardService.getData(search),
      staleTime: 5 * 60 * 1000, // 5 minutes
    })
  },
  meta: ({ loaderData }) => [
    {
      title: `Dashboard - ${loaderData?.title || 'Loading...'}`,
    },
    {
      name: 'description',
      content: 'View your dashboard analytics and data',
    },
  ],
  component: DashboardComponent,
})

function DashboardComponent() {
  const search = Route.useSearch()
  const data = Route.useLoaderData()
  const navigate = Route.useNavigate()
  
  return (
    <div>
      <h1>Dashboard</h1>
      <DashboardFilters 
        currentFilter={search.filter}
        onFilterChange={(filter) => 
          navigate({ search: { ...search, filter, page: 1 } })
        }
      />
      <DashboardContent data={data} />
    </div>
  )
}
```

## API Routes (Server Functions)

### API Route Definition
```typescript
// app/api.ts
import { json } from '@tanstack/react-start'
import { z } from 'zod'

const createPostSchema = z.object({
  title: z.string().min(1),
  content: z.string().min(10),
  tags: z.array(z.string()).optional(),
})

export async function POST({ request }: { request: Request }) {
  try {
    const body = await request.json()
    const result = createPostSchema.safeParse(body)
    
    if (!result.success) {
      return json(
        { error: 'Validation failed', issues: result.error.issues },
        { status: 400 }
      )
    }
    
    // Process the post creation
    const post = await postsService.create(result.data)
    
    return json({ post }, { status: 201 })
  } catch (error) {
    return json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function GET({ request }: { request: Request }) {
  const url = new URL(request.url)
  const search = url.searchParams.get('q') || ''
  const page = parseInt(url.searchParams.get('page') || '1')
  
  const posts = await postsService.search({ search, page })
  
  return json({ posts })
}
```

### Server Functions in Components
```typescript
// routes/blog/create.tsx
import { createServerFn } from '@tanstack/react-start'
import { redirect } from '@tanstack/react-router'
import { z } from 'zod'

const createPostFn = createServerFn(
  'POST',
  async (formData: FormData) => {
    const title = formData.get('title') as string
    const content = formData.get('content') as string
    
    const result = createPostSchema.safeParse({ title, content })
    
    if (!result.success) {
      throw new Error('Validation failed')
    }
    
    const post = await postsService.create(result.data)
    
    throw redirect({
      to: '/blog/$postId',
      params: { postId: post.id },
    })
  }
)

export const Route = createFileRoute('/blog/create')({
  component: CreatePostComponent,
})

function CreatePostComponent() {
  return (
    <form
      onSubmit={async (e) => {
        e.preventDefault()
        const formData = new FormData(e.currentTarget)
        await createPostFn(formData)
      }}
    >
      <input name="title" placeholder="Post title" required />
      <textarea name="content" placeholder="Post content" required />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

## SSR-Specific Patterns

### Hydration-Safe Components
```typescript
import { useIsomorphicLayoutEffect } from '~/hooks/useIsomorphicLayoutEffect'

export function ClientOnlyComponent() {
  const [isClient, setIsClient] = useState(false)
  
  useIsomorphicLayoutEffect(() => {
    setIsClient(true)
  }, [])
  
  if (!isClient) {
    return <div className="h-8 bg-gray-200 animate-pulse rounded" />
  }
  
  return <InteractiveComponent />
}

// hooks/useIsomorphicLayoutEffect.ts
import { useLayoutEffect, useEffect } from 'react'

export const useIsomorphicLayoutEffect = 
  typeof window !== 'undefined' ? useLayoutEffect : useEffect
```

### Environment Variables
```typescript
// app/env.ts
import { z } from 'zod'

const serverEnvSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
})

const clientEnvSchema = z.object({
  VITE_API_URL: z.string().url(),
  VITE_APP_NAME: z.string(),
})

function createEnv() {
  if (typeof window === 'undefined') {
    // Server-side
    return {
      ...serverEnvSchema.parse(process.env),
      ...clientEnvSchema.parse({
        VITE_API_URL: process.env.VITE_API_URL,
        VITE_APP_NAME: process.env.VITE_APP_NAME,
      }),
    }
  } else {
    // Client-side
    return clientEnvSchema.parse({
      VITE_API_URL: import.meta.env.VITE_API_URL,
      VITE_APP_NAME: import.meta.env.VITE_APP_NAME,
    })
  }
}

export const env = createEnv()
```

## Data Fetching Patterns

### TanStack Query with SSR
```typescript
// services/postsService.ts
import { queryOptions } from '@tanstack/react-query'
import { apiClient } from './apiClient'

export const postsService = {
  // Query options for reuse
  all: () => queryOptions({
    queryKey: ['posts'],
    queryFn: () => apiClient.get('posts').json<Post[]>(),
    staleTime: 5 * 60 * 1000,
  }),
  
  byId: (id: string) => queryOptions({
    queryKey: ['posts', id],
    queryFn: () => apiClient.get(`posts/${id}`).json<Post>(),
    staleTime: 10 * 60 * 1000,
  }),
  
  search: (params: SearchParams) => queryOptions({
    queryKey: ['posts', 'search', params],
    queryFn: () => apiClient.get('posts/search', { searchParams: params }).json<SearchResult>(),
    staleTime: 2 * 60 * 1000,
  }),
}

// Usage in route loader
export const Route = createFileRoute('/blog')({
  loader: ({ context: { queryClient } }) => {
    return queryClient.ensureQueryData(postsService.all())
  },
  component: BlogComponent,
})
```

### Mutations with Optimistic Updates
```typescript
// hooks/useCreatePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useNavigate } from '@tanstack/react-router'

export function useCreatePost() {
  const queryClient = useQueryClient()
  const navigate = useNavigate()
  
  return useMutation({
    mutationFn: postsService.create,
    onMutate: async (newPost) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['posts'] })
      
      // Snapshot the previous value
      const previousPosts = queryClient.getQueryData(['posts'])
      
      // Optimistically update to the new value
      queryClient.setQueryData(['posts'], (old: Post[]) => [
        ...old,
        { ...newPost, id: 'temp-id', createdAt: new Date() },
      ])
      
      return { previousPosts }
    },
    onError: (err, newPost, context) => {
      // Rollback on error
      queryClient.setQueryData(['posts'], context?.previousPosts)
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['posts'] })
    },
    onSuccess: (post) => {
      navigate({ to: '/blog/$postId', params: { postId: post.id } })
    },
  })
}
```

## Performance Optimization

### Streaming and Progressive Enhancement
```typescript
// Use React 18 streaming features
export const Route = createFileRoute('/dashboard')({
  loader: async ({ context: { queryClient } }) => {
    // Load critical data immediately
    const criticalData = await queryClient.ensureQueryData({
      queryKey: ['dashboard', 'critical'],
      queryFn: () => dashboardService.getCriticalData(),
    })
    
    // Prefetch non-critical data (will resolve after streaming)
    queryClient.prefetchQuery({
      queryKey: ['dashboard', 'analytics'],
      queryFn: () => dashboardService.getAnalytics(),
    })
    
    return { criticalData }
  },
  component: DashboardComponent,
})

function DashboardComponent() {
  const { criticalData } = Route.useLoaderData()
  
  return (
    <div>
      <CriticalDashboardSection data={criticalData} />
      <Suspense fallback={<AnalyticsLoadingSkeleton />}>
        <AnalyticsSection />
      </Suspense>
    </div>
  )
}
```

### Route-Based Code Splitting
```typescript
// Lazy load heavy components
export const Route = createLazyFileRoute('/dashboard/analytics')({
  component: () => {
    const AnalyticsDashboard = lazy(() => 
      import('~/components/app/AnalyticsDashboard').then(m => ({
        default: m.AnalyticsDashboard
      }))
    )
    
    return (
      <Suspense fallback={<div>Loading analytics...</div>}>
        <AnalyticsDashboard />
      </Suspense>
    )
  },
})
```

## Testing SSR Applications

### Component Testing with SSR Context
```typescript
// utils/testing/test-utils.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { createMemoryHistory, createRouter } from '@tanstack/react-router'
import { render } from '@testing-library/react'
import { routeTree } from '~/routeTree.gen'

export function renderWithRouter(
  component: React.ReactElement,
  { initialEntries = ['/'] } = {}
) {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  })
  
  const router = createRouter({
    routeTree,
    context: { queryClient },
    history: createMemoryHistory({ initialEntries }),
  })
  
  return render(
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  )
}
```

### API Route Testing
```typescript
// app/__tests__/api.test.ts
import { describe, it, expect } from 'vitest'
import { POST, GET } from '../api'

describe('API Routes', () => {
  it('creates a new post', async () => {
    const request = new Request('http://localhost/api/posts', {
      method: 'POST',
      body: JSON.stringify({
        title: 'Test Post',
        content: 'This is a test post',
      }),
      headers: { 'Content-Type': 'application/json' },
    })
    
    const response = await POST({ request })
    const data = await response.json()
    
    expect(response.status).toBe(201)
    expect(data.post).toBeDefined()
    expect(data.post.title).toBe('Test Post')
  })
})
```

## Development Commands
- `pnpm dev`: Start development server with SSR
- `pnpm build`: Build for production (server + client)
- `pnpm start`: Start production server
- `pnpm test`: Run unit tests
- `pnpm lint`: Check code quality
- `pnpm typecheck`: Type check without emitting files

## Best Practices
- Always consider SSR implications when writing components
- Use server functions for form submissions and mutations
- Implement proper error boundaries for both server and client
- Handle hydration mismatches gracefully with proper loading states
- Optimize for Core Web Vitals and SEO with streaming SSR
- Use progressive enhancement patterns for better resilience
- Implement proper caching strategies for both data and assets
- Monitor both server and client performance metrics
- Test critical paths with and without JavaScript
- Use proper meta tags and Open Graph for social sharing
- Implement proper security headers and CSP policies
- Handle authentication and authorization properly across SSR/client boundary